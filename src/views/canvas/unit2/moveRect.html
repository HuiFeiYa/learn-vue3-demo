<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>拖拽小方块</title>

    <style>
        #canvas {
            margin:50px;
            cursor: default;
            border: 1px solid black;
        }
        body{
          padding:0;
        }
    </style>
</head>
<body>
<canvas id="canvas" width="400" height="400">Canvas not supported</canvas>
<p>拖拽方块并实时重绘</p>
</body>
<script>
  let canvas = document.getElementById('canvas')
  context = canvas.getContext('2d')
    //初始时的矩形属性
    initX = 10,
  initY = 10,
  initWidth = 100,
  initHeight = 100,

  isDrag = false,
  controlRectWidth = 20,
  controlRectHeight = 20
  // 多边形存储
  polygons = {
    fillStyle:'lightgray',
    strokeStyle:'blue',
    // 存储矩形相对于canvas的距离
    loc:{x:0,y:0},
    height:initHeight,
    width:initWidth,
    // 存储鼠标相对于矩形的位置，这关系到绘制矩形的起点问题。
    offsetX:0,
    offsetY:0
  }
  // 绘制矩形形状
  let drawInitRect = () => {
    context.fillStyle = polygons.fillStyle
    context.rect(initX,initY,initWidth,initHeight)
    polygons.loc.x = initX
    polygons.loc.y = initY
    polygons.width = initWidth
    polygons.height = initHeight
    context.fill()
  }
  function showControl(ev) {
    const isIn = context.isPointInPath(ev.clientX - canvas.offsetTop,ev.clientY-canvas.offsetLeft)
    context.closePath()
    context.clearRect(0,0,canvas.width,canvas.height)
    if(isIn) {
      context.clearRect(0,0,canvas.width,canvas.height)
      context.rect(ev.clientX - polygons.offsetX - canvas.offsetTop, ev.clientY - polygons.offsetY - canvas.offsetLeft, initWidth, initHeight)
         drawControl(ev.clientX - polygons.offsetX - canvas.offsetTop, ev.clientY - polygons.offsetY - canvas.offsetLeft, initWidth, initHeight)
         drawLineRect(ev.clientX - polygons.offsetX - canvas.offsetTop, ev.clientY - polygons.offsetY - canvas.offsetLeft, initWidth, initHeight)
    }else {
      context.beginPath()
      context.rect(ev.clientX - polygons.offsetX - canvas.offsetTop, ev.clientY - polygons.offsetY - canvas.offsetLeft, initWidth, initHeight)
      context.stroke()
    }
  }
  let drawControl = (x,y,height,width)=>  {
    drawControlRect(x,y)
    drawControlRect(x,y + height)
    drawControlRect(x+width,y )
    drawControlRect(x+width,y + height)

  }
  let drawLineRect = (x,y,height,width) =>{
    context.strokeStyle = 'blue'
    context.moveTo(x,y)
    context.lineTo(x+width,y)
    context.lineTo(x+width,y+height)
    context.lineTo(x,y+height)
    context.closePath()
    context.stroke()
  }
  let drawControlRect = (x,y) => {
    // context.beginPath()
    context.fillStyle = '#f66'
    context.rect(x - controlRectWidth / 2,y - controlRectHeight/2,controlRectWidth,controlRectHeight)
    // context.fill()
    context.closePath()
  }
  /**
   * 当鼠标按下
   */
  canvas.onmousedown = ev =>{
    /**
     * 判断画布上的点是否在矩形中
     * 当前点在 cavas 上的位置 = ev.clientX - canvas.offsetTop(canvas相对于窗口左上角* 的位置)
     * 
     */ 
    isDrag = context.isPointInPath(ev.clientX - canvas.offsetTop,ev.clientY-canvas.offsetLeft)
    /**
     * 计算当前点击位置和 canvas 左上角点的距离。
     * ev.clientX 表示与窗口左上角的距离
     * polygons.loc.x 初始化值是 canvas 绘制元素(也就是矩形)距离canvas左上角的距离
     * 两者相减就是当前鼠标距离 canvas 左上角的距离,还要减去 canvas.offsetTop 相对于窗口的距离
     */ 
    polygons.offsetX = ev.clientX - polygons.loc.x - canvas.offsetTop
    polygons.offsetY = ev.clientY - polygons.loc.y - canvas.offsetLeft
    showControl(ev)
  }
  /**
   *  鼠标移动时
   */

   canvas.onmousemove = ev => {
     console.log('move')
     // 如果用户点击选中了矩形，那么接下来是重新绘制矩形位置的操作
     if(isDrag){
       context.beginPath()
       context.clearRect(0,0,canvas.width,canvas.height)
       showControl(ev)
       context.fill()
       context.stroke()
     }else{
       /**
        *  如果未选中矩形，判断当前点是否在矩形中，当鼠标划过矩形显示小手表示可移动
        */ 
        if (context.isPointInPath(ev.clientX - canvas.offsetTop,ev.clientY-canvas.offsetLeft)) {
          canvas.style.cursor = 'pointer'
        }else{
          canvas.style.cursor = 'default'
        }
     }
   }
   canvas.onmouseup = ev => {
     isDrag = false
     polygons.loc.x = ev.clientX - polygons.offsetX -  canvas.offsetTop
     polygons.loc.y = ev.clientY - polygons.offsetY - canvas.offsetLeft
     console.log('polygons',polygons)
   }
  drawInitRect()
</script>
</html>